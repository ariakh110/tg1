# ADR-0004: مدیریت چرخه عمر سفارش با ماشین حالت (State Machine) و رویدادها

- **وضعیت:** پذیرفته‌شده (Accepted)
- **تاریخ:** 2026-01-02

## زمینه (Context)

سفارش‌ها چندمرحله‌ای هستند و وضعیت‌ها برای کنترل عملیات حیاتی‌اند:

- جلوگیری از اقدام‌های نامعتبر (مثلاً بارگیری قبل از پرداخت)
- محاسبه و قفل کردن قیمت/شرایط
- مدیریت مهلت‌ها و لغو خودکار
- یکپارچگی با پرداخت‌ها و escrow

اگر وضعیت‌ها «شل» باشند، سیستم به سرعت دچار تناقض می‌شود (مثلاً پرداخت انجام شده ولی status هنوز OPEN است).

## تصمیم (Decision)

- یک enum مشترک برای `OrderStatus` تعریف می‌شود.
- انتقال‌ها از طریق یک سرویس مرکزی انجام می‌شود:
  - `OrderStateService.transition(order, event, actor, payload)`
- هر انتقال:
  - pre-condition دارد (role/ownership/current_status)
  - side-effect دارد (status history, notification)
  - در صورت مالی بودن، در `transaction.atomic` انجام می‌شود
- وضعیت‌ها و انتقال‌ها بر اساس `OrderType` محدود می‌شوند (BUY/SELL/CUT/SHIP/QC).

## دلایل (Rationale)

- کنترل‌پذیری و پیش‌بینی‌پذیری سیستم بالا می‌رود.
- تست‌پذیری افزایش می‌یابد (هر event → expected status).
- قابلیت گزارش‌گیری و audit دقیق‌تر می‌شود.

## پیامدها (Consequences)

### مثبت
- کاهش باگ‌های مربوط به وضعیت و پرداخت
- امکان افزودن timeoutها و اتوماسیون‌ها (Celery Beat) با اطمینان
- بهبود تجربه کاربری (نمایش مرحله‌ای و شفاف)

### منفی / ریسک‌ها
- نیاز به طراحی دقیق eventها و state transitions
- ممکن است تغییرات محصول در آینده نیازمند اصلاح state machine باشد
  - **راه‌حل:** نگهداشت ADRها و تغییر کنترل‌شده، و داشتن migration برای وضعیت‌ها در صورت لزوم

## گزینه‌های بررسی‌شده (Alternatives)

- وضعیت ساده + شرط‌های پراکنده در viewها: سریع در ابتدا، اما به‌سرعت غیرقابل نگهداری
- استفاده کامل از کتابخانه‌های FSM (مثل django-fsm): خوب، اما بعضاً محدودیت در چندنوع سفارش دارد.
  - انتخاب ما: می‌توانیم در MVP دستی و در صورت نیاز، django-fsm را فقط برای مدل Order اضافه کنیم.

## ارجاع‌ها

- معماری: `docs/architecture/architecture.md`
